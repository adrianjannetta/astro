<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moon Phase Widget</title>
  <style>
    :root{
      --bg: #0b1020;
      --card: #121a33;
      --text: #e8ecf7;
      --muted: #a9b4d0;
      --accent: #7aa2ff;
      --good: #7ee787;
      --bad: #ff7b72;
      --ring: rgba(122,162,255,.35);
    }
    @media (prefers-color-scheme: light) {
      :root{
        --bg: #f7f9ff;
        --card: #ffffff;
        --text: #0f172a;
        --muted: #5b6b8b;
        --accent: #305cff;
        --good: #0a7f3f;
        --bad: #b32121;
        --ring: rgba(48,92,255,.18);
      }
    }
    html,body{
      height:100%;
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
    }
    .wrap{
      min-height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      box-sizing:border-box;
    }
    .card{
      width:min(560px, 96vw);
      border-radius:24px;
      background: linear-gradient(180deg, var(--card), color-mix(in lab, var(--card), black 6%));
      box-shadow: 0 10px 30px rgba(0,0,0,.25), inset 0 0 0 1px var(--ring);
      padding: 22px;
    }
    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 12px;
    }
    .title{
      font-weight: 700;
      font-size: 20px;
      letter-spacing: .2px;
    }
    .timestamp{
      font-size: 12px;
      color: var(--muted);
    }
    .moonRow{
      display:grid;
      grid-template-columns: 220px 1fr;
      gap: 18px;
      align-items:center;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    @media (max-width: 520px){
      .moonRow{
        grid-template-columns: 1fr;
        justify-items:center;
      }
    }
    .moonCanvas{
      width: 220px;
      height: 220px;
      display:block;
      margin: 0 auto;
      border-radius: 999px;
      background: radial-gradient(120px 120px at 45% 40%, #e9edf5, #d7dbe6 60%, #b5bbcd 80%, #a0a7bd);
      box-shadow: inset -22px -16px 36px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.08);
    }
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px 14px;
      align-items:start;
    }
    .stat{
      background: color-mix(in lab, var(--card), black 6%);
      border-radius: 14px;
      padding: 12px 12px 10px 12px;
      box-shadow: inset 0 0 0 1px var(--ring);
    }
    .label{
      font-size: 12px;
      color: var(--muted);
      letter-spacing:.3px;
      margin-bottom: 6px;
    }
    .value{
      font-weight: 700;
      font-feature-settings: "lnum" 1, "tnum" 1;
    }
    .phaseBadge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background:color-mix(in lab, var(--accent), transparent 85%);
      color: var(--accent);
      font-weight:700;
      font-size: 13px;
      letter-spacing:.2px;
      box-shadow: inset 0 0 0 1px var(--ring);
    }
    .footerNote{
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="group" aria-label="Moon phase widget">
      <div class="header">
        <div class="title">Moon Right Now</div>
        <div class="phaseBadge" id="phaseName">Loading…</div>
      </div>

      <div class="moonRow">
        <!-- SVG moon drawing -->
        <svg id="moonSvg" class="moonCanvas" viewBox="0 0 220 220" aria-label="Moon phase image">
          <defs>
            <radialGradient id="moonTex" cx="40%" cy="38%" r="64%">
              <stop offset="0%" stop-color="#f3f5f9"/>
              <stop offset="60%" stop-color="#dee3ee"/>
              <stop offset="85%" stop-color="#c2c8da"/>
              <stop offset="100%" stop-color="#a4abc0"/>
            </radialGradient>
            <filter id="shadow">
              <feDropShadow dx="-8" dy="-9" stdDeviation="10" flood-color="black" flood-opacity=".35"/>
            </filter>
          </defs>
          <rect x="0" y="0" width="220" height="220" rx="110" ry="110" fill="url(#moonTex)"/>
          <!-- Terminator group injected by JS -->
          <g id="terminator" filter="url(#shadow)"></g>
          <!-- subtle limb highlight -->
          <circle cx="110" cy="110" r="108" fill="none" stroke="rgba(255,255,255,.3)" stroke-width="1.5"/>
        </svg>

        <div class="stats" id="stats">
          <div class="stat">
            <div class="label">Illumination</div>
            <div class="value" id="illum">—</div>
          </div>
          <div class="stat">
            <div class="label">Age since New</div>
            <div class="value" id="age">—</div>
          </div>
          <div class="stat">
            <div class="label">Distance</div>
            <div class="value" id="distance">—</div>
          </div>
          <div class="stat">
            <div class="label">Angular Diameter</div>
            <div class="value" id="ang">—</div>
          </div>
          <div class="stat">
            <div class="label">Next New Moon</div>
            <div class="value" id="nextNew">—</div>
          </div>
          <div class="stat">
            <div class="label">Next Full Moon</div>
            <div class="value" id="nextFull">—</div>
          </div>
        </div>
      </div>

      <div class="footerNote">
        <span id="updated">Updated —</span> · Times use your device’s timezone · Refreshes hourly
      </div>
    </div>
  </div>

<script>
/* Minimal Moon calculations adapted from SunCalc (BSD-2-Clause) by Vladimir Agafonkin
   Source: https://github.com/mourner/suncalc  (embedded here to make this widget standalone)
   Slightly reduced & formatted.
*/
(function(){
  const PI = Math.PI;
  const sin = Math.sin, cos = Math.cos, tan = Math.tan, asin = Math.asin, atan2 = Math.atan2, acos = Math.acos;
  const dayMs = 1000*60*60*24;

  const rad = PI/180;
  const e = rad * 23.4397; // obliquity of the Earth

  // date to julian days
  function toJulian(date) { return date.valueOf()/dayMs - 0.5 + 2440588; }
  function fromJulian(j) { return new Date((j + 0.5 - 2440588)*dayMs); }
  function toDays(date) { return toJulian(date) - 2451545; }

  function rightAscension(l, b) { return atan2(sin(l)*cos(e) - tan(b)*sin(e), cos(l)); }
  function declination(l, b) { return asin(sin(b)*cos(e) + cos(b)*sin(e)*sin(l)); }
  function azimuth(H, phi, dec) { return atan2(sin(H), cos(H)*sin(phi) - tan(dec)*cos(phi)); }
  function altitude(H, phi, dec) { return asin(sin(phi)*sin(dec) + cos(phi)*cos(dec)*cos(H)); }
  function siderealTime(d, lw) { return rad*(280.16 + 360.9856235*d) - lw; }

  // solar mean anomaly
  function solarMeanAnomaly(d) { return rad*(357.5291 + 0.98560028*d); }
  // ecliptic longitude of the sun
  function eclipticLongitude(M) {
    const C = rad*(1.9148*sin(M) + 0.02*sin(2*M) + 0.0003*sin(3*M)); // equation of center
    const P = rad*102.9372; // perihelion of the Earth
    return M + C + P + PI;
  }
  function sunCoords(d) {
    const M = solarMeanAnomaly(d);
    const L = eclipticLongitude(M);
    return { dec: declination(L, 0), ra: rightAscension(L, 0) };
  }

  // moon stuff
  function moonCoords(d) {
    const L = rad*(218.316 + 13.176396*d); // ecliptic longitude
    const M = rad*(134.963 + 13.064993*d); // mean anomaly
    const F = rad*(93.272 + 13.229350*d);  // mean distance

    const l  = L + rad*6.289*sin(M); // longitude
    const b  = rad*5.128*sin(F);     // latitude
    const dt = 385001 - 20905*cos(M); // distance (km)

    return { ra: rightAscension(l, b), dec: declination(l, b), dist: dt };
  }

  // returns Illuminated fraction, phase angle, and waxing flag
  function getMoonIllumination(date) {
    const d = toDays(date);
    const s = sunCoords(d);
    const m = moonCoords(d);

    const sdist = 149598000; // distance from Earth to Sun in km

    const phi = acos(sin(s.dec)*sin(m.dec) + cos(s.dec)*cos(m.dec)*cos(s.ra - m.ra));
    const inc = atan2(sdist*sin(phi), m.dist - sdist*cos(phi));
    const fraction = (1 + cos(inc)) / 2;
    const angle = atan2(cos(s.dec)*sin(s.ra - m.ra), sin(s.dec)*cos(m.dec) - cos(s.dec)*sin(m.dec)*cos(s.ra - m.ra));
    return { fraction, phaseAngle: inc, angle, waxing: angle > 0 };
  }

  function getMoonPosition(date, lat, lng){
    const lw = rad*-lng;
    const phi = rad*lat;
    const d = toDays(date);

    const c = moonCoords(d);
    const H = siderealTime(d, lw) - c.ra;
    const h = altitude(H, phi, c.dec);

    // altitude correction for refraction
    const hRef = h + rad*0.017 / tan(h + rad*10.26/(h + rad*5.10));

    return { azimuth: azimuth(H, phi, c.dec), altitude: hRef, distance: c.dist, parallacticAngle: atan2(sin(H), tan(phi)*cos(c.dec) - sin(c.dec)*cos(H)) };
  }

  // expose to window
  window.__MoonCalc = { getMoonIllumination, getMoonPosition };
})();

// Utility formatters
function pad(n){ return String(n).padStart(2,"0"); }
function fmtTime(d){
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
}
function kmToMiles(km){ return km * 0.621371; }
function rad2deg(r){ return r * 180/Math.PI; }
function deg2arcmin(d){ return d * 60; }

// Compute phase name from phase (0..1), where 0 = New, 0.5=Full
function phaseName(p){
  // normalize
  p = ((p % 1) + 1) % 1;
  const eps = 1/29.530588; // about 0.0339
  if (p < eps || p > 1-eps) return "New Moon";
  if (Math.abs(p-0.25) < eps) return "First Quarter";
  if (Math.abs(p-0.5) < eps) return "Full Moon";
  if (Math.abs(p-0.75) < eps) return "Last Quarter";
  if (p < 0.25) return "Waxing Crescent";
  if (p < 0.5) return "Waxing Gibbous";
  if (p < 0.75) return "Waning Gibbous";
  return "Waning Crescent";
}

// approximate phase (0..1) from illumination and waxing sign
function illuminationToPhase(frac, waxing){
  // phase angle mapped to 0..1 by acos(2f-1)/pi
  let p = Math.acos(2*frac - 1) / Math.PI;
  if (waxing) p = 1 - p;
  return p;
}

function synodicAgeDays(phase){ return phase * 29.530588853; }

function findNextPhase(targetPhase, startDate){
  // scan forward in ~3 hour steps to find date where phase crosses targetPhase
  const stepMs = 3*60*60*1000;
  let t0 = new Date(startDate.getTime());
  let prev = phaseValue(t0);
  for (let i=0; i<2000; i++){
    t0 = new Date(t0.getTime()+stepMs);
    const cur = phaseValue(t0);
    // handle wrap-around
    let a = prev, b = cur, tp = targetPhase;
    if (b < a) b += 1; // unwrap
    if (tp < a) tp += 1;
    if (a <= tp && tp <= b){
      // refine by binary search
      let lo = new Date(t0.getTime()-stepMs), hi = t0;
      for (let j=0;j<24;j++){
        const mid = new Date((lo.getTime()+hi.getTime())/2);
        const pm = phaseValue(mid);
        let pma = pm, pla = phaseValue(lo);
        if (pma < pla) pma += 1;
        if (pma >= targetPhase && pla <= targetPhase) hi = mid; else lo = mid;
      }
      return hi;
    }
    prev = cur;
  }
  return null;
}

function phaseValue(d){
  const {fraction, waxing} = __MoonCalc.getMoonIllumination(d);
  return illuminationToPhase(fraction, waxing);
}

// Draw the moon terminator on the SVG
function drawMoon(svg, fraction, waxing){
  const g = svg.querySelector("#terminator");
  g.innerHTML = "";
  const R = 110, cx = 110, cy = 110;

  // background dark disk for night side
  const bg = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  bg.setAttribute("cx", cx); bg.setAttribute("cy", cy); bg.setAttribute("r", R);
  bg.setAttribute("fill", "#0b1020");
  g.appendChild(bg);

  // mask to reveal illuminated portion
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
  mask.setAttribute("id","litMask");
  const mrect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  mrect.setAttribute("x","0"); mrect.setAttribute("y","0");
  mrect.setAttribute("width","220"); mrect.setAttribute("height","220");
  mrect.setAttribute("fill","black");
  mask.appendChild(mrect);

  const litCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  litCircle.setAttribute("cx", cx); litCircle.setAttribute("cy", cy); litCircle.setAttribute("r", R);
  litCircle.setAttribute("fill","white");
  mask.appendChild(litCircle);

  // ellipse width based on phase fraction (0..1)
  // k = |2f - 1| ranges 0..1; rx shrinks for crescents
  const k = Math.abs(2*fraction - 1);
  const ellipse = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
  ellipse.setAttribute("cx", waxing ? cx + 0.001 : cx - 0.001); // avoid aliasing line
  ellipse.setAttribute("cy", cy);
  ellipse.setAttribute("rx", R * k);
  ellipse.setAttribute("ry", R);
  ellipse.setAttribute("fill","black");

  // For crescent halves, we invert mask logic
  if (fraction < 0.5){
    // Darken half opposite illuminated sliver
    // Use an extra rect to cover half and then carve sliver with ellipse
    const half = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    if (waxing){
      half.setAttribute("x", cx); half.setAttribute("y", cy-R);
      half.setAttribute("width", R); half.setAttribute("height", 2*R);
    }else{
      half.setAttribute("x", cx-R); half.setAttribute("y", cy-R);
      half.setAttribute("width", R); half.setAttribute("height", 2*R);
    }
    half.setAttribute("fill","black");
    mask.appendChild(half);
    mask.appendChild(ellipse);
  }else{
    // Gibbous: start from dark circle, then add ellipse of light
    // Build a white shape with ellipse + half rect
    const litGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const half = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    if (waxing){
      // right-heavy light
      half.setAttribute("x", cx); half.setAttribute("y", cy-R);
      half.setAttribute("width", R); half.setAttribute("height", 2*R);
    }else{
      half.setAttribute("x", cx-R); half.setAttribute("y", cy-R);
      half.setAttribute("width", R); half.setAttribute("height", 2*R);
    }
    half.setAttribute("fill","white");
    ellipse.setAttribute("fill","white");
    litGroup.appendChild(half);
    litGroup.appendChild(ellipse);
    // Replace default litCircle with litGroup
    mask.innerHTML = '<rect x="0" y="0" width="220" height="220" fill="black"/>';
    mask.appendChild(litGroup);
  }

  defs.appendChild(mask);
  g.appendChild(defs);

  // Apply mask to a full bright moon to reveal only lit part
  const litMoon = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  litMoon.setAttribute("cx", cx); litMoon.setAttribute("cy", cy); litMoon.setAttribute("r", R);
  litMoon.setAttribute("fill", "url(#moonTex)");
  litMoon.setAttribute("mask","url(#litMask)");
  g.appendChild(litMoon);
}

function update(){
  const now = new Date();
  const lat = 0, lng = 0; // not required for illumination, distance is geocentric
  const ill = __MoonCalc.getMoonIllumination(now);
  const phase = illuminationToPhase(ill.fraction, ill.waxing); // 0..1
  const age = synodicAgeDays(phase);

  // distance & angular diameter
  const pos = __MoonCalc.getMoonPosition(now, lat, lng);
  const distKm = pos.distance;
  const angDiameterDeg = 2 * Math.atan(1737.4 / distKm) * 180/Math.PI; // degrees
  const angArcmin = deg2arcmin(angDiameterDeg);

  // find next new & full
  const nextNew = findNextPhase(0, now);
  const nextFull = findNextPhase(0.5, now);

  // draw
  const svg = document.getElementById("moonSvg");
  drawMoon(svg, ill.fraction, ill.waxing);

  // text
  const pct = (ill.fraction*100).toFixed(1) + "%";
  document.getElementById("illum").textContent = `${pct} ${ill.waxing ? "(waxing)" : "(waning)"}`;
  document.getElementById("age").textContent = `${age.toFixed(2)} days`;
  document.getElementById("distance").textContent = `${distKm.toLocaleString()} km (${Math.round(kmToMiles(distKm)).toLocaleString()} mi)`;
  document.getElementById("ang").textContent = `${angArcmin.toFixed(1)} arcmin`;
  document.getElementById("phaseName").textContent = phaseName(phase);

  const nf = new Intl.DateTimeFormat(undefined, {year:'numeric', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit'});
  document.getElementById("nextNew").textContent = nextNew ? nf.format(nextNew) : "—";
  document.getElementById("nextFull").textContent = nextFull ? nf.format(nextFull) : "—";

  document.getElementById("updated").textContent = `Updated ${nf.format(now)}`;
}

// Initial render then hourly refresh
update();
setInterval(update, 60*60*1000);
</script>
</body>
</html>
